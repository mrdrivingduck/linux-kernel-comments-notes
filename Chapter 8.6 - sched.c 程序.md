# Chapter 8.6 - sched.c ç¨‹åº

Created by : Mr Dk.

2019 / 08 / 16 17:05

Ningbo, Zhejiang, China

---

## 8.6 sched.c ç¨‹åº

### 8.6.1 åŠŸèƒ½æè¿°

å†…æ ¸ä¸­æœ‰å…³ä»»åŠ¡ (è¿›ç¨‹) è°ƒåº¦ç®¡ç†çš„ç¨‹åºï¼ŒåŒ…å«ï¼š

* å‡ ä¸ªæœ‰å…³è°ƒåº¦çš„åŸºæœ¬å‡½æ•°
* ä¸€äº›ç®€å•çš„ç³»ç»Ÿè°ƒç”¨
* ç³»ç»Ÿæ—¶é’Ÿä¸­æ–­çš„å®šæ—¶å‡½æ•°å’Œè½¯ç›˜é©±åŠ¨å™¨å®šæ—¶ç¨‹åº

#### 8.6.1.1 è°ƒåº¦å‡½æ•°

è°ƒåº¦å‡½æ•° `schedule()` è´Ÿè´£é€‰æ‹©ç³»ç»Ÿä¸­ä¸‹ä¸€ä¸ªè¦è¿è¡Œçš„ä»»åŠ¡

é¦–å…ˆï¼Œå¯¹æ‰€æœ‰ä»»åŠ¡è¿›è¡Œæ£€æµ‹ï¼Œ__å”¤é†’ä»»ä½•ä¸€ä¸ªå·²ç»å¾—åˆ°ä¿¡å·çš„ä»»åŠ¡__

* æ£€æŸ¥æŠ¥è­¦å™¨å®šæ—¶å€¼ alarmï¼Œå¦‚æœå·²ç»è¿‡æ—¶ï¼Œå°±åœ¨ä¿¡å·ä½å›¾ä¸­è®¾ç½® `SIGALRM` ä¿¡å·ï¼Œæ¸…é™¤ alarm
* å¦‚æœè¿›ç¨‹çš„ä¿¡å·ä½å›¾ä¸­ï¼Œé™¤å»è¢«é˜»å¡çš„ä¿¡å·å¤–è¿˜æœ‰å…¶å®ƒä¿¡å·ï¼Œå¹¶å¤„äºå¯ä¸­æ–­ç¡çœ çŠ¶æ€ `TASK_RUNNING`ï¼Œåˆ™ç½®ä»»åŠ¡ä¸ºå°±ç»ªçŠ¶æ€ `TASK_RUNNING`

éšåæ˜¯è°ƒåº¦çš„æ ¸å¿ƒéƒ¨åˆ†

æ ¹æ®è¿›ç¨‹çš„ __æ—¶é—´ç‰‡__ å’Œ __ä¼˜å…ˆçº§__

é€‰æ‹©éšåè¦æ‰§è¡Œçš„ä»»åŠ¡

å¹¶åˆ©ç”¨ `switch_to()` åˆ‡æ¢åˆ°è¯¥ä»»åŠ¡

è‹¥æ‰€æœ‰å°±ç»ªæ€ä»»åŠ¡çš„æ—¶é—´ç‰‡éƒ½ä¸º 0

åˆ™æ ¹æ®ä»»åŠ¡çš„ä¼˜å…ˆçº§é‡æ–°è®¾ç½®æ¯ä¸ªä»»åŠ¡çš„è¿è¡Œæ—¶é—´ç‰‡

å†æ¬¡é‡æ–°æ£€æŸ¥æ‰€æœ‰ä»»åŠ¡çš„æ—¶é—´ç‰‡ï¼Œå¹¶è¿›è¡Œé€‰æ‹©

#### 8.6.1.2 ç¡çœ å’Œå”¤é†’å‡½æ•°

`sleep_on()` å‡½æ•°çš„ä¸»è¦åŠŸèƒ½ï¼š

* å½“ä¸€ä¸ªè¿›ç¨‹æ‰€è¯·æ±‚çš„èµ„æº __æ­£è¢«å ç”¨__ æˆ– __ä¸åœ¨å†…å­˜__
* æš‚æ—¶å°†è¯¥è¿›ç¨‹åˆ‡æ¢å‡ºå»ï¼Œæ”¾åœ¨ç­‰å¾…é˜Ÿåˆ—ä¸­ç­‰å¾…ä¸€æ®µæ—¶é—´

å‡½æ•°æ¶‰åŠä¸‰ä¸ªä»»åŠ¡æŒ‡é’ˆçš„æ“ä½œï¼š

* `*p` - ç­‰å¾…é˜Ÿåˆ—å¤´æŒ‡é’ˆ
  * æ–‡ä»¶ç³»ç»Ÿä¸­ `i_wait` æŒ‡é’ˆ
  * å†…å­˜ç¼“å†²ä¸­ `buffer_wait` æŒ‡é’ˆ
  * ...
* `tmp` - å­˜å‚¨åœ¨å½“å‰ä»»åŠ¡çš„å†…æ ¸æ€å †æ ˆä¸Šï¼ŒæŒ‡å‘å‰ä¸€ä¸ªæ­£åœ¨ç­‰å¾…çš„ä»»åŠ¡
* `current` - å½“å‰ä»»åŠ¡æŒ‡é’ˆ

`sleep_on()` å‡½æ•°ä½¿ `*p` æŒ‡å‘å½“å‰ä»»åŠ¡ï¼Œä½¿å½“å‰ä»»åŠ¡çš„ `tmp` æŒ‡é’ˆæŒ‡å‘ `*p` åŸæ¥æŒ‡å‘çš„æ­£åœ¨ç­‰å¾…çš„ä»»åŠ¡

å½“å‡ ä¸ªè¿›ç¨‹ä¸ºäº†ç­‰å¾…åŒä¸€èµ„æºè€Œåˆ†åˆ«è°ƒç”¨ `sleep_on()` æ—¶

æ„ç­‘å‡ºäº†ä¸€ä¸ªç­‰å¾…é˜Ÿåˆ—ï¼š

![8-7](./img/8-7.png)

> è¿™é˜Ÿåˆ—å¾ˆå¥‡æ€ª å› ä¸ºå®ƒå¥½åƒä¸æ˜¯ FIFO çš„.. ğŸ˜¥

å°†è¿›ç¨‹æ’å…¥é˜Ÿåˆ—åï¼Œ`sleep_on()` å‡½æ•°å°±ä¼šè°ƒç”¨ `schedule()` å‡½æ•°å»æ‰§è¡Œåˆ«çš„è¿›ç¨‹

å½“è¿›ç¨‹è¢«å”¤é†’æ—¶ï¼Œå°±ä¼šæŠŠæ¯”å®ƒæ›´æ—©è¿›å…¥é˜Ÿåˆ—çš„è¿›ç¨‹å”¤é†’

å”¤é†’å‡½æ•° `wake_up()` ç”¨äºæŠŠç­‰å¾…å¯ç”¨èµ„æºçš„æŒ‡å®šä»»åŠ¡ç½®ä½å°±ç»ªçŠ¶æ€

`sleep_on()` è¿˜æœ‰ä¸€ç§å½¢å¼ - `interruptible_sleep_on()` å‡½æ•°

* è°ƒåº¦å…¶å®ƒä»»åŠ¡å‰ï¼Œå°†å½“å‰ä»»åŠ¡ç½®ä¸º __å¯ä¸­æ–­ç­‰å¾…çŠ¶æ€__
* åœ¨æœ¬ä»»åŠ¡è¢«å”¤é†’åï¼Œè¿˜éœ€è¦åˆ¤æ–­é˜Ÿåˆ—ä¸Šæ˜¯å¦æœ‰åæ¥çš„ä»»åŠ¡ï¼›è‹¥æœ‰ï¼Œåˆ™éœ€è¦å…ˆè°ƒåº¦å®ƒä»¬
* Linux 0.12 ä¸­ï¼Œè¿™ä¸¤ç§æƒ…å†µéƒ½ç”± `sleep_on()` å®ç°ï¼Œç”¨ä»»åŠ¡çš„çŠ¶æ€ä½œä¸ºå‚æ•°åŒºåˆ†è¿™ä¸¤ç§æƒ…å†µ

### 8.6.2 ä»£ç æ³¨é‡Š

> è¿›ç¨‹è°ƒåº¦å’Œä¿¡å·å¤„ç†ä¹‹é—´è”ç³»è¾ƒå¤š
>
> æ‰€ä»¥æˆ‘è§‰å¾—è¦ç»“åˆ `sys_call.s` å’Œ `signal.c` ä¸€å—å„¿çœ‹
>
> æ‰èƒ½åŠ å¼ºç†è§£

é¦–å…ˆå®šä¹‰äº†ä¸¤ä¸ªå®ï¼Œç”¨äºå¿«é€Ÿæ“ä½œä¿¡å·ï¼š

* ä¿¡å·çš„ç¼–å·æ˜¯ä» 1 å¼€å§‹ï¼Œåˆ° 32 ä¸ºæ­¢
* ä½†ä¿¡å·åœ¨ bitmap ä¸­æ˜¯ä»ç¬¬ 0 ä½åˆ°ç¬¬ 31 ä½ï¼Œæ‰€ä»¥è¦æ³¨æ„è¿™ä¸ªè½¬å˜

```c
// å–ç¼–å·ä¸º nr çš„ä¿¡å·åœ¨ bitmap ä¸­çš„å¯¹åº”æ•°å€¼
#define _S(nr) (1 << ((nr)-1))
// é™¤ SIGKILL å’Œ SIGSTOP ä¿¡å·ä»¥å¤–ï¼Œå…¶å®ƒä¿¡å·æ˜¯å¯ä»¥è¢«é˜»å¡çš„
#define _BLOCKABLE (~(_S(SIGKILL) | _S(SIGSTOP)))
```

> å…³äºä¿¡å·å’Œé˜»å¡çš„ä¸€ç‚¹ç†è§£ï¼š
>
> å†…æ ¸é€šè¿‡åœ¨è¿›ç¨‹ PCB ä¸­è®¾ç½®ä¿¡å·ä½æ¥ç»™è¿›ç¨‹å‘é€ä¿¡å·
>
> å¦‚æœè¿›ç¨‹å¤„äºå¯ä¸­æ–­ç¡çœ çŠ¶æ€ï¼Œåˆ™è®¾ç½®ä¿¡å·ä½åå”¤é†’è¿›ç¨‹
>
> å¦‚æœè¿›ç¨‹å¤„äºä¸å¯ä¸­æ–­ç¡çœ çŠ¶æ€ï¼Œåˆ™åªè®¾ç½®ä¿¡å·ä½
>
> è¿›ç¨‹å¤„ç†ä¿¡å·çš„æ—¶æœºåœ¨å…¶ä»å†…æ ¸æ€è¿”å›ç”¨æˆ·æ€æ—¶
>
> * æ”¶åˆ°ä¿¡å·åè¿›ç¨‹é€€å‡º
> * è¿›ç¨‹å¿½ç•¥ä¿¡å·
> * æ•æ‰æŸç±»ä¿¡å· - è°ƒç”¨å¯¹åº”çš„ä¿¡å·å¤„ç†å‡½æ•°
>
> ä¸€ç§å¯èƒ½çš„æ€è·¯ï¼š
>
> å‘è¿›ç¨‹å‘é€æŸä¸ªä¿¡å·åï¼Œä¼šå°†è¯¥ä¿¡å·çš„é˜»å¡ä½ç½®ä½
>
> è¿›ç¨‹å¤„ç†å®Œè¯¥ä¿¡å·åï¼Œå°†è¯¥é˜»å¡ä½å¤ä½
>
> å¦‚æœè¿›ç¨‹å¤„ç†ä¿¡å·æœŸé—´ï¼Œåˆæ¥äº†åŒæ ·çš„ä¿¡å·
>
> é‚£ä¹ˆä¼šè¢«é˜»å¡ä½ç»™å±è”½æ‰ï¼Œå³ä¸¢å¼ƒ
>
> (æ‰€è°“çš„ä¸å¯é ä¿¡å·)
>
> å¯é çš„ä¿¡å·å¤„ç†å½¢å¼ï¼šæ’é˜Ÿè®°å½•ï¼Œé‚£ä¹ˆå°±ä¸å­˜åœ¨ä¸¢å¼ƒçš„é—®é¢˜

OKï¼Œçœ‹ä»£ç ï¼Œä¸€å¼€å§‹æ˜¯å†…æ ¸è°ƒè¯•å‡½æ•°

ç”¨äºæ˜¾ç¤ºå„ä»»åŠ¡çš„è¯¦ç»†ä¿¡æ¯ï¼š

```c
void show_task(int nr, struct task_struct * p)
{
    int i, j = 4096-sizeof(struct task_struct); // å†…æ ¸æ ˆæœ€å¤§å®¹é‡
                                                // PCB å’Œå†…æ ¸æ€å †æ ˆå…±å ä¸€é¡µç‰©ç†å†…å­˜
    
    printk("%d: pid=%d, state=%d, father=%d, child=%d, ",
            nr, p->pid, p->state, p->p_pptr->pid,
            p->p_cptr ? p->p_cptr->pid : -1);
    
    i = 0;
    while (i < j && !((char *)(p+1))[i])
        i++; // æ£€æµ‹æŒ‡å®šä»»åŠ¡æ•°æ®ç»“æ„ä»¥åç­‰äº 0 çš„å­—èŠ‚æ•° (å¤§çº¦)
             // å³ï¼Œå†…æ ¸æ€å †æ ˆç©ºé—²å­—èŠ‚æ•°
    
    printk("%d/%d chars free in kstack\n\r", i, j);
    printk(" PC=%08X.", *(1019 + (unsigned long *) p));
    if (p->p_ysptr || p->p_osptr)
        printk(" Younger sib=%d, older sib=%d\n\r",
                p->p_ysptr ? p->p_ysptr->pid : -1,
                p->p_osptr ? p->p_osptr->pid : -1);
    else
        printk("\n\r");
}

void show_state(void)
{
    int i;
    
    printk("\rTask-info:\n\r");
    for (i = 0; i < NR_TASKS; i++) // NR_TASKS ä¸ºå†…æ ¸æ”¯æŒçš„æœ€å¤šä»»åŠ¡æ•°
        if (task[i]) // ä»»åŠ¡æŒ‡é’ˆä¸ä¸ºç©º (ä»»åŠ¡å­˜åœ¨)
            show_task(i, task[i]);
}
```

æ¥ä¸‹æ¥æ˜¯ä¸€äº›ç›¸å…³æ•°æ®ç»“æ„çš„å®šä¹‰ï¼š

```c
union task_union {
    struct task_struct task;
    char stack[PAGE_SIZE];
};
// ???
// union å¤§ä¸€ä¸Š C è¯­è¨€è¯¾çš„æ—¶å€™ä¸€ç¬”å¸¦è¿‡
// æœ‰ç©ºå†å¼„æ˜ç™½è¿™å…·ä½“æ˜¯ä¸ªå•¥

// ä»»åŠ¡ 0 åˆå§‹åŒ–
static union task_union init_task = { INIT_TASK, };

// åˆå§‹åŒ–ç³»ç»Ÿæ»´ç­”
// volatile å’Œç¼–è¯‘å™¨æœ‰å…³ï¼Œéœ€è¦æœ‰ç©ºå¼„å¼„æ˜ç™½
// ç³»ç»Ÿæ»´ç­” 10ms ä¸€æ¬¡ï¼Œæ˜¯ç³»ç»Ÿæ—¶é’Ÿå•ä½
unsigned long volatile jiffies = 0;
// å¼€æœºæ—¶é—´
unsigned long startup_time = 0;
// ä¸ºè°ƒæ•´æ—¶é’Ÿè€Œéœ€è¦å¢åŠ çš„æ»´ç­”æ•°
int jiffies_offset = 0;

// å½“å‰ä»»åŠ¡æŒ‡é’ˆï¼ŒæŒ‡å‘ä»»åŠ¡ 0
struct task_struct *current = &(init_task.task);
// ä¸Šä¸€ä¸ªä½¿ç”¨åå¤„ç†å™¨çš„ä»»åŠ¡æŒ‡é’ˆ
struct task_struct *last_task_used_math = NULL; 
// å®šä¹‰ä»»åŠ¡æŒ‡é’ˆæ•°ç»„ï¼Œç¬¬ä¸€é¡¹è¢«åˆå§‹åŒ–ä¸ºä»»åŠ¡ 0
struct task_struct *task[NR_TASKS] = { &(init_task.task), };

// ä»»åŠ¡ 0 çš„ç”¨æˆ·æ€å †æ ˆ
// 1K é¡¹ï¼Œå…± 4KB
long user_stack[ PAGE_SIZE >> 2 ];

// SS:ESP
// SS çš„æ®µé€‰æ‹©ç¬¦ä¸ºå†…æ ¸æ•°æ®æ®µé€‰æ‹©ç¬¦ 0x10
// ESP æ˜¯é€†å‘å…¥æ ˆçš„ (åœ°å€é€’å‡)ï¼Œå› æ­¤åˆå§‹åœ°å€æŒ‡å‘ user_stack çš„æœ€åä¸€é¡¹
struct {
    long *a;
    short b;
} stack_start = { & user_stack [ PAGE_SIZE >> 2 ], 0x10 };
```

æ¥ä¸‹æ¥æ˜¯ä¸€ä¸ªå­å‡½æ•°

ç”¨äºåœ¨ä»»åŠ¡è¢«è°ƒåº¦åˆ‡æ¢ä¹‹å

ä¿å­˜åŸä»»åŠ¡çš„åå¤„ç†å™¨çŠ¶æ€ï¼Œæ¢å¤æ–°ä»»åŠ¡çš„åå¤„ç†å™¨çŠ¶æ€

```c
void math_state_restore()
{
    if (last_task_used_math == current)
    {
        return; // ä»»åŠ¡æ²¡å˜ï¼Œç›´æ¥è¿”å›
    }
    __asm__("fwait"); // å‘é€åå¤„ç†å™¨æŒ‡ä»¤ä¹‹å‰è¦å…ˆå‘ WAIT æŒ‡ä»¤
    if (last_task_used_math)
    {
        __asm__("fnsave %0"::"m" (last_task_used_math->tss.i387));
    }
    last_task_used_math = current; // æŒ‡å‘å½“å‰ä»»åŠ¡
    if (current->used_math) { // å½“å‰ä»»åŠ¡ä½¿ç”¨è¿‡åå¤„ç†å™¨
        __asm__("frstor %0"::"m" (current->tss.i387)); // æ¢å¤åå¤„ç†å™¨çŠ¶æ€
    } else { // é¦–æ¬¡ä½¿ç”¨åå¤„ç†å™¨
        __asm__("fninit"::); // åˆå§‹åŒ–åå¤„ç†å™¨
        current->used_math = 1; // è®¾ç½®å·²ä½¿ç”¨åå¤„ç†å™¨æ ‡å¿—
    }
}
```

ä¸‹é¢æ˜¯æœ€æ ¸å¿ƒçš„ `schedule()` å‡½æ•° (ä¼šè¢«å¾ˆå¤šåœ°æ–¹è°ƒç”¨åˆ°ï¼)ï¼š

* è°ƒåº¦è¿›ç¨‹
* å¤„ç†ä¿¡å·

```c
void schedule(void)
{
    int i, next, c;
    struct task_struct **p;
    
    // é¦–å…ˆæ£€æµ‹å„è¿›ç¨‹çš„å®šæ—¶å™¨
    // å”¤é†’å·²å¾—åˆ°ä¿¡å·çš„å¯ä¸­æ–­ä»»åŠ¡
    for (p = &LAST_TASK; p > &FIRST_TASK; --p)
        if (*p) {
            if ((*p)->timeout && (*p)->timeout < jiffies) {
                // å·²è®¾ç½®å®šæ—¶å™¨ && å·²ç»è¶…æ—¶
                (*p)->timeout = 0; // å¤ä½å®šæ—¶å™¨
                if ((*p)->state == TASK_INTERRUPTIBLE)
                    (*p)->state = TASK_RUNNING;
            }
            if ((*p)->alarm && (*p)->alarm < jiffies) {
                // å·²è®¾ç½® SIGALRM ä¿¡å· && å·²ç»è¶…æ—¶
                (*p)->signal |= (1 << (SIGALRM-1)); // ç½® SIGALRM ä¿¡å·
                (*p)->alarm = 0;
            }
            if (((*p)->signal & ~(_BLOCKALBE & (*p)->blocked)) &&
                (*p)->state == TASK_INTERRUPTIBLE})
                // ä¿¡å· bitmap ä¸­å­˜åœ¨é™¤è¢«é˜»å¡çš„ä¿¡å·å¤–è¿˜æœ‰ä¿¡å·å­˜åœ¨
                // ä¸”ä»»åŠ¡å¤„äºå¯ä¸­æ–­ç­‰å¾…çŠ¶æ€
                (*p)->state = TASK_RUNNING;
        }
    
    // è°ƒåº¦ç¨‹åºçš„ä¸»è¦éƒ¨åˆ†
    while (1) {
        c = -1; // æ•°å€¼æœ€å¤§çš„æ—¶é—´ç‰‡
        next = 0; // ä¸‹ä¸€ä¸ªè¦è°ƒåº¦çš„ä»»åŠ¡
        i = NR_TASKS; // ä»»åŠ¡ index
        p = &task[NR_TASKS]; // æœ€åä¸€ä¸ªä»»åŠ¡é¡¹
        
        // ä»æœ€åä¸€ä¸ªä»»åŠ¡å¼€å§‹å¾ªç¯
        while (--i) {
            if (!&--p)
                continue; // è·³è¿‡ç©ºæ§½
            if ((*p)->state == TASK_RUNNING && (*p)->counter > c)
                c = (*p)->counter, next = i;
        }
        
        // æœ‰å¤§äº 0 çš„æ—¶é—´ç‰‡ï¼Œåˆ™è·³å‡ºå¾ªç¯ï¼Œå°†ä»»åŠ¡åˆ‡æ¢åˆ° next
        // æˆ–æ²¡æœ‰ä¸€ä¸ªå¯è¿è¡Œä»»åŠ¡ (c == -1, next == 0)ï¼Œåˆ™è·³å‡ºå¾ªç¯ï¼Œåˆ‡æ¢åˆ°ä»»åŠ¡ 0
        if (c) break;

        // counter == 0ï¼Œå³æ‰€æœ‰è¿›ç¨‹çš„æ—¶é—´ç‰‡éƒ½ä¸º 0
        // æ ¹æ®ä¼˜å…ˆçº§é‡æ–°è®¡ç®— counter
        // counter = counter/2 + priority
        for (p = &LAST_TASK; p > &FIRST_TASK; --p)
            if (*p)
                (*p)->counter = ((*p)->counter >> 1) + (*p)->priority;
    }
    
    switch_to(next); // ä»»åŠ¡åˆ‡æ¢å®
}
```


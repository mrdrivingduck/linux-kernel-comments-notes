# Chapter 8.6 - sched.c ç¨‹åº

Created by : Mr Dk.

2019 / 08 / 18 11:50

Ningbo, Zhejiang, China

---

## 8.6 sched.c ç¨‹åº

### 8.6.1 åŠŸèƒ½æè¿°

å†…æ ¸ä¸­æœ‰å…³ä»»åŠ¡ (è¿›ç¨‹) è°ƒåº¦ç®¡ç†çš„ç¨‹åºï¼ŒåŒ…å«ï¼š

* å‡ ä¸ªæœ‰å…³è°ƒåº¦çš„åŸºæœ¬å‡½æ•°
* ä¸€äº›ç®€å•çš„ç³»ç»Ÿè°ƒç”¨
* ç³»ç»Ÿæ—¶é’Ÿä¸­æ–­çš„å®šæ—¶å‡½æ•°å’Œè½¯ç›˜é©±åŠ¨å™¨å®šæ—¶ç¨‹åº

#### 8.6.1.1 è°ƒåº¦å‡½æ•°

è°ƒåº¦å‡½æ•° `schedule()` è´Ÿè´£é€‰æ‹©ç³»ç»Ÿä¸­ä¸‹ä¸€ä¸ªè¦è¿è¡Œçš„ä»»åŠ¡

é¦–å…ˆï¼Œå¯¹æ‰€æœ‰ä»»åŠ¡è¿›è¡Œæ£€æµ‹ï¼Œ__å”¤é†’ä»»ä½•ä¸€ä¸ªå·²ç»å¾—åˆ°ä¿¡å·çš„ä»»åŠ¡__

* æ£€æŸ¥æŠ¥è­¦å™¨å®šæ—¶å€¼ alarmï¼Œå¦‚æœå·²ç»è¿‡æ—¶ï¼Œå°±åœ¨ä¿¡å·ä½å›¾ä¸­è®¾ç½® `SIGALRM` ä¿¡å·ï¼Œæ¸…é™¤ alarm
* å¦‚æœè¿›ç¨‹çš„ä¿¡å·ä½å›¾ä¸­ï¼Œé™¤å»è¢«é˜»å¡çš„ä¿¡å·å¤–è¿˜æœ‰å…¶å®ƒä¿¡å·ï¼Œå¹¶å¤„äºå¯ä¸­æ–­ç¡çœ çŠ¶æ€ `TASK_RUNNING`ï¼Œåˆ™ç½®ä»»åŠ¡ä¸ºå°±ç»ªçŠ¶æ€ `TASK_RUNNING`

éšåæ˜¯è°ƒåº¦çš„æ ¸å¿ƒéƒ¨åˆ†

æ ¹æ®è¿›ç¨‹çš„ __æ—¶é—´ç‰‡__ å’Œ __ä¼˜å…ˆçº§__

é€‰æ‹©éšåè¦æ‰§è¡Œçš„ä»»åŠ¡

å¹¶åˆ©ç”¨ `switch_to()` åˆ‡æ¢åˆ°è¯¥ä»»åŠ¡

è‹¥æ‰€æœ‰å°±ç»ªæ€ä»»åŠ¡çš„æ—¶é—´ç‰‡éƒ½ä¸º 0

åˆ™æ ¹æ®ä»»åŠ¡çš„ä¼˜å…ˆçº§é‡æ–°è®¾ç½®æ¯ä¸ªä»»åŠ¡çš„è¿è¡Œæ—¶é—´ç‰‡

å†æ¬¡é‡æ–°æ£€æŸ¥æ‰€æœ‰ä»»åŠ¡çš„æ—¶é—´ç‰‡ï¼Œå¹¶è¿›è¡Œé€‰æ‹©

#### 8.6.1.2 ç¡çœ å’Œå”¤é†’å‡½æ•°

`sleep_on()` å‡½æ•°çš„ä¸»è¦åŠŸèƒ½ï¼š

* å½“ä¸€ä¸ªè¿›ç¨‹æ‰€è¯·æ±‚çš„èµ„æº __æ­£è¢«å ç”¨__ æˆ– __ä¸åœ¨å†…å­˜__
* æš‚æ—¶å°†è¯¥è¿›ç¨‹åˆ‡æ¢å‡ºå»ï¼Œæ”¾åœ¨ç­‰å¾…é˜Ÿåˆ—ä¸­ç­‰å¾…ä¸€æ®µæ—¶é—´

å‡½æ•°æ¶‰åŠä¸‰ä¸ªä»»åŠ¡æŒ‡é’ˆçš„æ“ä½œï¼š

* `*p` - ç­‰å¾…é˜Ÿåˆ—å¤´æŒ‡é’ˆ
  * æ–‡ä»¶ç³»ç»Ÿä¸­ `i_wait` æŒ‡é’ˆ
  * å†…å­˜ç¼“å†²ä¸­ `buffer_wait` æŒ‡é’ˆ
  * ...
* `tmp` - å­˜å‚¨åœ¨å½“å‰ä»»åŠ¡çš„å†…æ ¸æ€å †æ ˆä¸Šï¼ŒæŒ‡å‘å‰ä¸€ä¸ªæ­£åœ¨ç­‰å¾…çš„ä»»åŠ¡
* `current` - å½“å‰ä»»åŠ¡æŒ‡é’ˆ

`sleep_on()` å‡½æ•°ä½¿ `*p` æŒ‡å‘å½“å‰ä»»åŠ¡ï¼Œä½¿å½“å‰ä»»åŠ¡çš„ `tmp` æŒ‡é’ˆæŒ‡å‘ `*p` åŸæ¥æŒ‡å‘çš„æ­£åœ¨ç­‰å¾…çš„ä»»åŠ¡

å½“å‡ ä¸ªè¿›ç¨‹ä¸ºäº†ç­‰å¾…åŒä¸€èµ„æºè€Œåˆ†åˆ«è°ƒç”¨ `sleep_on()` æ—¶

æ„ç­‘å‡ºäº†ä¸€ä¸ªç­‰å¾…é˜Ÿåˆ—ï¼š

![8-7](./img/8-7.png)

> è¿™é˜Ÿåˆ—å¾ˆå¥‡æ€ª å› ä¸ºå®ƒå¥½åƒä¸æ˜¯ FIFO çš„.. ğŸ˜¥
>
> æ›´åƒä¸€ä¸ªé“¾å¼æ ˆ
>
> `*p` æŒ‡å‘é˜Ÿå°¾ (æ ˆé¡¶)
>
> åé¢çœ‹ä»£ç å¯ä»¥å¾—çŸ¥ï¼Œè¿™ä¸ªæ•°æ®ç»“æ„æ˜¯ FILO çš„

å°†è¿›ç¨‹æ’å…¥é˜Ÿåˆ—åï¼Œ`sleep_on()` å‡½æ•°å°±ä¼šè°ƒç”¨ `schedule()` å‡½æ•°å»æ‰§è¡Œåˆ«çš„è¿›ç¨‹

å½“è¿›ç¨‹è¢«å”¤é†’æ—¶ï¼Œå°±ä¼šæŠŠæ¯”å®ƒæ›´æ—©è¿›å…¥é˜Ÿåˆ—çš„è¿›ç¨‹å”¤é†’

å”¤é†’å‡½æ•° `wake_up()` ç”¨äºæŠŠç­‰å¾…å¯ç”¨èµ„æºçš„æŒ‡å®šä»»åŠ¡ç½®ä½å°±ç»ªçŠ¶æ€

`sleep_on()` è¿˜æœ‰ä¸€ç§å½¢å¼ - `interruptible_sleep_on()` å‡½æ•°

* è°ƒåº¦å…¶å®ƒä»»åŠ¡å‰ï¼Œå°†å½“å‰ä»»åŠ¡ç½®ä¸º __å¯ä¸­æ–­ç­‰å¾…çŠ¶æ€__
* åœ¨æœ¬ä»»åŠ¡è¢«å”¤é†’åï¼Œè¿˜éœ€è¦åˆ¤æ–­é˜Ÿåˆ—ä¸Šæ˜¯å¦æœ‰åæ¥çš„ä»»åŠ¡ï¼›è‹¥æœ‰ï¼Œåˆ™éœ€è¦å…ˆè°ƒåº¦å®ƒä»¬
* Linux 0.12 ä¸­ï¼Œè¿™ä¸¤ç§æƒ…å†µéƒ½ç”± `sleep_on()` å®ç°ï¼Œç”¨ä»»åŠ¡çš„çŠ¶æ€ä½œä¸ºå‚æ•°åŒºåˆ†è¿™ä¸¤ç§æƒ…å†µ

### 8.6.2 ä»£ç æ³¨é‡Š

> è¿›ç¨‹è°ƒåº¦å’Œä¿¡å·å¤„ç†ä¹‹é—´è”ç³»è¾ƒå¤š
>
> æ‰€ä»¥æˆ‘è§‰å¾—è¦ç»“åˆ `sys_call.s` å’Œ `signal.c` ä¸€å—å„¿çœ‹
>
> æ‰èƒ½åŠ å¼ºç†è§£

#### ä¿¡å·æ“ä½œå®

é¦–å…ˆå®šä¹‰äº†ä¸¤ä¸ªå®ï¼Œç”¨äºå¿«é€Ÿæ“ä½œä¿¡å·ï¼š

* ä¿¡å·çš„ç¼–å·æ˜¯ä» 1 å¼€å§‹ï¼Œåˆ° 32 ä¸ºæ­¢
* ä½†ä¿¡å·åœ¨ bitmap ä¸­æ˜¯ä»ç¬¬ 0 ä½åˆ°ç¬¬ 31 ä½ï¼Œæ‰€ä»¥è¦æ³¨æ„è¿™ä¸ªè½¬å˜

```c
// å–ç¼–å·ä¸º nr çš„ä¿¡å·åœ¨ bitmap ä¸­çš„å¯¹åº”æ•°å€¼
#define _S(nr) (1 << ((nr)-1))
// é™¤ SIGKILL å’Œ SIGSTOP ä¿¡å·ä»¥å¤–ï¼Œå…¶å®ƒä¿¡å·æ˜¯å¯ä»¥è¢«é˜»å¡çš„
#define _BLOCKABLE (~(_S(SIGKILL) | _S(SIGSTOP)))
```

> å…³äºä¿¡å·å’Œé˜»å¡çš„ä¸€ç‚¹ç†è§£ï¼š
>
> å†…æ ¸é€šè¿‡åœ¨è¿›ç¨‹ PCB ä¸­è®¾ç½®ä¿¡å·ä½æ¥ç»™è¿›ç¨‹å‘é€ä¿¡å·
>
> å¦‚æœè¿›ç¨‹å¤„äºå¯ä¸­æ–­ç¡çœ çŠ¶æ€ï¼Œåˆ™è®¾ç½®ä¿¡å·ä½åå”¤é†’è¿›ç¨‹
>
> å¦‚æœè¿›ç¨‹å¤„äºä¸å¯ä¸­æ–­ç¡çœ çŠ¶æ€ï¼Œåˆ™åªè®¾ç½®ä¿¡å·ä½
>
> è¿›ç¨‹å¤„ç†ä¿¡å·çš„æ—¶æœºåœ¨å…¶ä»å†…æ ¸æ€è¿”å›ç”¨æˆ·æ€æ—¶
>
> * æ”¶åˆ°ä¿¡å·åè¿›ç¨‹é€€å‡º
> * è¿›ç¨‹å¿½ç•¥ä¿¡å·
> * æ•æ‰æŸç±»ä¿¡å· - è°ƒç”¨å¯¹åº”çš„ä¿¡å·å¤„ç†å‡½æ•°
>
> ä¸€ç§å¯èƒ½çš„æ€è·¯ï¼š
>
> å‘è¿›ç¨‹å‘é€æŸä¸ªä¿¡å·åï¼Œä¼šå°†è¯¥ä¿¡å·çš„é˜»å¡ä½ç½®ä½
>
> è¿›ç¨‹å¤„ç†å®Œè¯¥ä¿¡å·åï¼Œå°†è¯¥é˜»å¡ä½å¤ä½
>
> å¦‚æœè¿›ç¨‹å¤„ç†ä¿¡å·æœŸé—´ï¼Œåˆæ¥äº†åŒæ ·çš„ä¿¡å·
>
> é‚£ä¹ˆä¼šè¢«é˜»å¡ä½ç»™å±è”½æ‰ï¼Œå³ä¸¢å¼ƒ
>
> (æ‰€è°“çš„ä¸å¯é ä¿¡å·)
>
> å¯é çš„ä¿¡å·å¤„ç†å½¢å¼ï¼šæ’é˜Ÿè®°å½•ï¼Œé‚£ä¹ˆå°±ä¸å­˜åœ¨ä¸¢å¼ƒçš„é—®é¢˜

OKï¼Œçœ‹ä»£ç ï¼Œä¸€å¼€å§‹æ˜¯å†…æ ¸è°ƒè¯•å‡½æ•°

#### æ˜¾ç¤ºå„ä»»åŠ¡çš„è¯¦ç»†ä¿¡æ¯

```c
void show_task(int nr, struct task_struct * p)
{
    int i, j = 4096-sizeof(struct task_struct); // å†…æ ¸æ ˆæœ€å¤§å®¹é‡
                                                // PCB å’Œå†…æ ¸æ€å †æ ˆå…±å ä¸€é¡µç‰©ç†å†…å­˜
    
    printk("%d: pid=%d, state=%d, father=%d, child=%d, ",
            nr, p->pid, p->state, p->p_pptr->pid,
            p->p_cptr ? p->p_cptr->pid : -1);
    
    i = 0;
    while (i < j && !((char *)(p+1))[i])
        i++; // æ£€æµ‹æŒ‡å®šä»»åŠ¡æ•°æ®ç»“æ„ä»¥åç­‰äº 0 çš„å­—èŠ‚æ•° (å¤§çº¦)
             // å³ï¼Œå†…æ ¸æ€å †æ ˆç©ºé—²å­—èŠ‚æ•°
    
    printk("%d/%d chars free in kstack\n\r", i, j);
    printk(" PC=%08X.", *(1019 + (unsigned long *) p));
    if (p->p_ysptr || p->p_osptr)
        printk(" Younger sib=%d, older sib=%d\n\r",
                p->p_ysptr ? p->p_ysptr->pid : -1,
                p->p_osptr ? p->p_osptr->pid : -1);
    else
        printk("\n\r");
}

void show_state(void)
{
    int i;
    
    printk("\rTask-info:\n\r");
    for (i = 0; i < NR_TASKS; i++) // NR_TASKS ä¸ºå†…æ ¸æ”¯æŒçš„æœ€å¤šä»»åŠ¡æ•°
        if (task[i]) // ä»»åŠ¡æŒ‡é’ˆä¸ä¸ºç©º (ä»»åŠ¡å­˜åœ¨)
            show_task(i, task[i]);
}
```

#### æ•°æ®ç»“æ„å®šä¹‰

```c
union task_union {
    struct task_struct task;
    char stack[PAGE_SIZE];
};
// ???
// union å¤§ä¸€ä¸Š C è¯­è¨€è¯¾çš„æ—¶å€™ä¸€ç¬”å¸¦è¿‡
// æœ‰ç©ºå†å¼„æ˜ç™½è¿™å…·ä½“æ˜¯ä¸ªå•¥

// ä»»åŠ¡ 0 åˆå§‹åŒ–
static union task_union init_task = { INIT_TASK, };

// åˆå§‹åŒ–ç³»ç»Ÿæ»´ç­”
// volatile å’Œç¼–è¯‘å™¨æœ‰å…³ï¼Œéœ€è¦æœ‰ç©ºå¼„å¼„æ˜ç™½
// ç³»ç»Ÿæ»´ç­” 10ms ä¸€æ¬¡ï¼Œæ˜¯ç³»ç»Ÿæ—¶é’Ÿå•ä½
unsigned long volatile jiffies = 0;
// å¼€æœºæ—¶é—´
unsigned long startup_time = 0;
// ä¸ºè°ƒæ•´æ—¶é’Ÿè€Œéœ€è¦å¢åŠ çš„æ»´ç­”æ•°
int jiffies_offset = 0;

// å½“å‰ä»»åŠ¡æŒ‡é’ˆï¼ŒæŒ‡å‘ä»»åŠ¡ 0
struct task_struct *current = &(init_task.task);
// ä¸Šä¸€ä¸ªä½¿ç”¨åå¤„ç†å™¨çš„ä»»åŠ¡æŒ‡é’ˆ
struct task_struct *last_task_used_math = NULL; 
// å®šä¹‰ä»»åŠ¡æŒ‡é’ˆæ•°ç»„ï¼Œç¬¬ä¸€é¡¹è¢«åˆå§‹åŒ–ä¸ºä»»åŠ¡ 0
struct task_struct *task[NR_TASKS] = { &(init_task.task), };

// ä»»åŠ¡ 0 çš„ç”¨æˆ·æ€å †æ ˆ
// 1K é¡¹ï¼Œå…± 4KB
long user_stack[ PAGE_SIZE >> 2 ];

// SS:ESP
// SS çš„æ®µé€‰æ‹©ç¬¦ä¸ºå†…æ ¸æ•°æ®æ®µé€‰æ‹©ç¬¦ 0x10
// ESP æ˜¯é€†å‘å…¥æ ˆçš„ (åœ°å€é€’å‡)ï¼Œå› æ­¤åˆå§‹åœ°å€æŒ‡å‘ user_stack çš„æœ€åä¸€é¡¹
struct {
    long *a;
    short b;
} stack_start = { & user_stack [ PAGE_SIZE >> 2 ], 0x10 };
```

æ¥ä¸‹æ¥æ˜¯ä¸€ä¸ªå­å‡½æ•°

ç”¨äºåœ¨ä»»åŠ¡è¢«è°ƒåº¦åˆ‡æ¢ä¹‹å

ä¿å­˜åŸä»»åŠ¡çš„åå¤„ç†å™¨çŠ¶æ€ï¼Œæ¢å¤æ–°ä»»åŠ¡çš„åå¤„ç†å™¨çŠ¶æ€

```c
void math_state_restore()
{
    if (last_task_used_math == current)
    {
        return; // ä»»åŠ¡æ²¡å˜ï¼Œç›´æ¥è¿”å›
    }
    __asm__("fwait"); // å‘é€åå¤„ç†å™¨æŒ‡ä»¤ä¹‹å‰è¦å…ˆå‘ WAIT æŒ‡ä»¤
    if (last_task_used_math)
    {
        __asm__("fnsave %0"::"m" (last_task_used_math->tss.i387));
    }
    last_task_used_math = current; // æŒ‡å‘å½“å‰ä»»åŠ¡
    if (current->used_math) { // å½“å‰ä»»åŠ¡ä½¿ç”¨è¿‡åå¤„ç†å™¨
        __asm__("frstor %0"::"m" (current->tss.i387)); // æ¢å¤åå¤„ç†å™¨çŠ¶æ€
    } else { // é¦–æ¬¡ä½¿ç”¨åå¤„ç†å™¨
        __asm__("fninit"::); // åˆå§‹åŒ–åå¤„ç†å™¨
        current->used_math = 1; // è®¾ç½®å·²ä½¿ç”¨åå¤„ç†å™¨æ ‡å¿—
    }
}
```

#### è°ƒåº¦å‡½æ•° schedule()

ä¸‹é¢æ˜¯æœ€æ ¸å¿ƒçš„ `schedule()` å‡½æ•° (ä¼šè¢«å¾ˆå¤šåœ°æ–¹è°ƒç”¨åˆ°ï¼)ï¼š

* è°ƒåº¦è¿›ç¨‹
* å¤„ç†ä¿¡å·

```c
void schedule(void)
{
    int i, next, c;
    struct task_struct **p;
    
    // é¦–å…ˆæ£€æµ‹å„è¿›ç¨‹çš„å®šæ—¶å™¨
    // å”¤é†’å·²å¾—åˆ°ä¿¡å·çš„å¯ä¸­æ–­ä»»åŠ¡
    for (p = &LAST_TASK; p > &FIRST_TASK; --p)
        if (*p) {
            if ((*p)->timeout && (*p)->timeout < jiffies) {
                // å·²è®¾ç½®å®šæ—¶å™¨ && å·²ç»è¶…æ—¶
                (*p)->timeout = 0; // å¤ä½å®šæ—¶å™¨
                if ((*p)->state == TASK_INTERRUPTIBLE)
                    (*p)->state = TASK_RUNNING;
            }
            if ((*p)->alarm && (*p)->alarm < jiffies) {
                // å·²è®¾ç½® SIGALRM ä¿¡å· && å·²ç»è¶…æ—¶
                (*p)->signal |= (1 << (SIGALRM-1)); // ç½® SIGALRM ä¿¡å·
                (*p)->alarm = 0;
            }
            if (((*p)->signal & ~(_BLOCKALBE & (*p)->blocked)) &&
                (*p)->state == TASK_INTERRUPTIBLE})
                // ä¿¡å· bitmap ä¸­å­˜åœ¨é™¤è¢«é˜»å¡çš„ä¿¡å·å¤–è¿˜æœ‰ä¿¡å·å­˜åœ¨
                // ä¸”ä»»åŠ¡å¤„äºå¯ä¸­æ–­ç­‰å¾…çŠ¶æ€
                (*p)->state = TASK_RUNNING;
        }
    
    // è°ƒåº¦ç¨‹åºçš„ä¸»è¦éƒ¨åˆ†
    while (1) {
        c = -1; // æ•°å€¼æœ€å¤§çš„æ—¶é—´ç‰‡
        next = 0; // ä¸‹ä¸€ä¸ªè¦è°ƒåº¦çš„ä»»åŠ¡
        i = NR_TASKS; // ä»»åŠ¡ index
        p = &task[NR_TASKS]; // æœ€åä¸€ä¸ªä»»åŠ¡é¡¹
        
        // ä»æœ€åä¸€ä¸ªä»»åŠ¡å¼€å§‹å¾ªç¯
        while (--i) {
            if (!&--p)
                continue; // è·³è¿‡ç©ºæ§½
            if ((*p)->state == TASK_RUNNING && (*p)->counter > c)
                c = (*p)->counter, next = i;
        }
        
        // æœ‰å¤§äº 0 çš„æ—¶é—´ç‰‡ï¼Œåˆ™è·³å‡ºå¾ªç¯ï¼Œå°†ä»»åŠ¡åˆ‡æ¢åˆ° next
        // æˆ–æ²¡æœ‰ä¸€ä¸ªå¯è¿è¡Œä»»åŠ¡ (c == -1, next == 0)ï¼Œåˆ™è·³å‡ºå¾ªç¯ï¼Œåˆ‡æ¢åˆ°ä»»åŠ¡ 0
        if (c) break;

        // æ‰€æœ‰è¿›ç¨‹çš„æ—¶é—´ç‰‡éƒ½ä¸º 0
        // æ ¹æ®ä¼˜å…ˆçº§é‡æ–°è®¡ç®— counter
        // counter = counter/2 + priority
        for (p = &LAST_TASK; p > &FIRST_TASK; --p)
            if (*p)
                (*p)->counter = ((*p)->counter >> 1) + (*p)->priority;
    }
    
    switch_to(next); // ä»»åŠ¡åˆ‡æ¢å®
}
```

æ¥ä¸‹æ¥çš„å„ç§å‡½æ•°ä¸­å…¨éƒ¨éƒ½ä½¿ç”¨äº†è¯¥ `schedule()` å‡½æ•°

#### ç³»ç»Ÿè°ƒç”¨ pause()

* å°†å½“å‰ä»»åŠ¡è®¾å®šä¸ºå¯ä¸­æ–­ç­‰å¾…çŠ¶æ€ï¼Œå¹¶é‡æ–°è°ƒåº¦
* (è¿˜æ²¡æœ‰å®Œå…¨å®ç°ï¼Ÿ)

```c
int sys_pause(void)
{
    current->state = TASK_INTERRUPTIBLE;
    schedule();
    return 0;
}
```

#### ç¡çœ å‡½æ•° sleep_on()

* å°†å½“å‰ä»»åŠ¡ç½®ä¸º __å¯ä¸­æ–­ç¡çœ çŠ¶æ€__ æˆ– __ä¸å¯ä¸­æ–­ç¡çœ çŠ¶æ€__
* å°†ç­‰å¾…é˜Ÿåˆ—å¤´æŒ‡é’ˆæŒ‡å‘å½“å‰ä»»åŠ¡
* å‚æ•° `state` å¯ä»¥ä¸º `TASK_UNINTERRUPTIBLE` æˆ– `TASK_INTERRUPTIBLE`
  * ä¸å¯ä¸­æ–­ç¡çœ çŠ¶æ€éœ€è¦åˆ©ç”¨ `wake_up()` å‡½æ•°æ˜ç¡®å”¤é†’
  * å¯ä¸­æ–­ç¡çœ çŠ¶æ€å¯ä»¥é€šè¿‡ä¿¡å·ã€ä»»åŠ¡è¶…æ—¶ç­‰æ‰‹æ®µå”¤é†’

```c
static inline void __sleep_on(struct task_struct **p, int state)
{
    struct task_struct *tmp;
    
    if (!p) // æŒ‡é’ˆæ‰€æŒ‡å¯¹è±¡å¯ä»¥ä¸º NULLï¼Œä½†æŒ‡é’ˆæœ¬èº«ä¸ä¼šä¸º 0
        return;
    if (current == &(init_task.task))
        panic("task[0] trying to sleep");
    
    // æ’å…¥ç­‰å¾…é˜Ÿåˆ—
    tmp = *p;
    *p = current;
    current->state = state;
repeat:
    schedule(); // é‡æ–°è°ƒåº¦
    
    // ä»»åŠ¡è¢«å”¤é†’åï¼Œå°†ä»è¿™é‡Œç»§ç»­æ‰§è¡Œ
    // å¦‚æœç­‰å¾…é˜Ÿåˆ—å¤´æŒ‡é’ˆå¹¶éæŒ‡å‘è‡ªå·±
    // è¯´æ˜ä¹‹åè¿˜æœ‰è¿›ç¨‹è¿›å…¥äº†ç­‰å¾…é˜Ÿåˆ—
    // å…ˆå°†é˜Ÿå¤´ç½®ä¸ºå°±ç»ªçŠ¶æ€ï¼Œå°†è‡ªèº«ç½®ä¸ºä¸å¯ä¸­æ–­ç­‰å¾…çŠ¶æ€
    // é˜Ÿåˆ—ä¸­çš„è¿›ç¨‹ä½¿ç”¨ wake_up() ä¾æ¬¡æ˜¾å¼å”¤é†’å‰ä¸€ä¸ªä»»åŠ¡
    if (*p && *p != current) {
        (**p).state = 0;
        current->state = TASK_UNINTERRUPTIBLE;
        goto repeat;
    }
    
    // æ­¤æ—¶ï¼Œä»»åŠ¡è¢«çœŸæ­£å”¤é†’ï¼Œ*p == current
    if (!*p)
        printk("Warning: *P = NULL\n\r");
    if (*p = tmp)
        // å¤´æŒ‡é’ˆæŒ‡å‘é˜Ÿåˆ—ä¸­çš„å‰ä¸€ä¸ªä»»åŠ¡
        // å¦‚æœè¯¥ä»»åŠ¡å­˜åœ¨ï¼Œåˆ™å”¤é†’
        // ç­‰å¾…é˜Ÿåˆ—å¤´æŒ‡é’ˆæœ€ç»ˆä¼šå˜ä¸º NULL
        tmp->state = 0;
}

// ä¸Šè¿°å‡½æ•°æ˜¯æ¥ä¸‹æ¥ä¸¤ä¸ªå‡½æ•°çš„å®ç°å‡½æ•°ï¼š
void interruptible_sleep_on(struct task_struct **p)
{
    __sleep_on(p, TASK_INTERRUPTIBLE);
}

void sleep_on(struct task_struct **p)
{
    __sleep_on(p, TASK_UNINTERRUPTIBLE);
}
```

#### å”¤é†’å‡½æ•° wake_up()

* å”¤é†’ä¸å¯ä¸­æ–­ç­‰å¾…ä»»åŠ¡
* ç”±äºæ–°ç­‰å¾…ä»»åŠ¡æ’å…¥åœ¨ç­‰å¾…é˜Ÿåˆ—çš„å¤´æŒ‡é’ˆå¤„ï¼Œå› æ­¤å”¤é†’çš„æ˜¯æœ€åè¿›å…¥ç­‰å¾…é˜Ÿåˆ—çš„ä»»åŠ¡

```c
void wake_up(struct task_struct **p)
{
    if (p && *p) {
        if ((**p).state == TASK_STOPPED)
            printk("wake_up: TASK_STOPPED");
        if ((**p).state == TASK_ZOMBIE)
            printk("wake_up: TASK_ZOMBIE");
        (**p).state = 0; // TASK_RUNNING
    }
}
```

#### å†…æ ¸å®šæ—¶å™¨

```c
#define TIME_REQUESTS 64 // æœ€å¤š 64 ä¸ªå®šæ—¶å™¨

static struct timer_list {
    long jiffies;            // å®šæ—¶æ»´ç­”æ•°
    void (*fn)();            // å®šæ—¶å¤„ç†ç¨‹åº
    struct timer_list *next; // æŒ‡å‘ä¸‹ä¸€ä¸ªå®šæ—¶å™¨
} timer_list[TIME_REQUESTS], * next_timer = NULL; // å®šæ—¶å™¨é˜Ÿåˆ—å¤´æŒ‡é’ˆ

void add_timer(long jiffies, void (*fn)(void))
{
    struct timer_list *p;
    
    if (!fn) // å¤„ç†ç¨‹åºæŒ‡é’ˆä¸ºç©º
        return;
    
    cli(); // å…³ä¸­æ–­
    
    if (jiffies <= 0) // å®šæ—¶å™¨çš„å€¼ â‰¤ 0ï¼Œåˆ™ç«‹åˆ»è°ƒç”¨å¤„ç†ç¨‹åºï¼Œä¸åŠ å…¥é“¾è¡¨
        (fn)();
    else {
        // ä»å®šæ—¶å™¨ä¸­æ‰¾ä¸€ä¸ªç©ºé—²é¡¹
        for (p = timer_list; p < timer_list + TIME_REQUESTS; p++)
            if (!p->fn)
                break;
        
        if (p >= timer_list + TIME_REQUESTS) // å®šæ—¶å™¨æ•°ç»„ç”¨å®Œ
            panic("No more time requests free");
        p->fn = fn;
        p->jiffies = jiffies;
        p->next = next_timer;
        next_timer = p; // æ’å…¥å®šæ—¶å™¨é˜Ÿå¤´
        
        // é“¾è¡¨æŒ‰å®šæ—¶å€¼ä»å°åˆ°å¤§æ’åº
        // æ’åºæ—¶å‡å»æ’åœ¨å‰é¢çš„å®šæ—¶å™¨æ‰€éœ€è¦çš„æ»´ç­”æ•°
        // å¤„ç†å®šæ—¶å™¨æ—¶ï¼Œåªéœ€è¦æŸ¥çœ‹è¡¨å¤´çš„å®šæ—¶å™¨æ˜¯å¦åˆ°æœŸ
        while (p->next && p->next->jiffies < p->jiffies) {
            p->jiffies -= p->next->jiffies;
            
            fn = p->fn;
            p->fn = p->next->fn;
            p->next->fn = fn;
            
            jiffies = p->jiffies;
            p->jiffies = p->next->jiffies;
            p->next->jiffies = jiffies;
            
            p = p->next;
        }
    }
    
    sti(); // å¼€ä¸­æ–­
}
```

#### æ—¶é’Ÿä¸­æ–­å¤„ç†å‡½æ•°

* ç”± `sys_call.s` ä¸­çš„ `_timer_interrupt` è°ƒç”¨
* è°ƒç”¨æ—¶ï¼Œä¼šå°†å½“å‰ CPU çš„ CPL å‹å…¥å †æ ˆï¼Œä½œä¸ºå‡½æ•°å‚æ•°
  * è¡¨ç¤ºä¸­æ–­å‘ç”Ÿæ—¶ï¼ŒCPU æ­£åœ¨æ‰§è¡Œç”¨æˆ·ä»£ç è¿˜æ˜¯å†…æ ¸ä»£ç 

æ‰§è¡Œè®¡æ—¶æ›´æ–°æ“ä½œï¼Œä»¥åŠä»»åŠ¡åˆ‡æ¢

```c
void do_timer(long cpl)
{
    // é»‘å±æ“ä½œ
    static int blanked = 0;
    if (blankcount || !blankinterval) {
        if (blanked)
            unblank_screen();
        if (blankcount)
            blankcount--;
        blanked = 0;
    } else if (!blanked) {
        blank_screen();
        blanked = 1;
    }
    
    // ç¡¬ç›˜æ“ä½œè¶…æ—¶
    if (hd_timeout)
        if (!--hd_timeout)
            hd_times_out();
    // æ‰¬å£°å™¨
    if (beepcount)
        if (!--beepcount)
            sysbeepstop();
    
    // å¦‚æœå½“å‰ä»£ç è¿è¡Œåœ¨å†…æ ¸æ€ï¼Œåˆ™é€’å¢ stime
    // å¦‚æœå½“å‰ä»£ç è¿è¡Œåœ¨ç”¨æˆ·æ€ï¼Œåˆ™é€’å¢ utime
    if (cpl) // cpl == 3
        current->utime++;
    else
        current->stime++;
    
    // å¦‚æœè®¾ç½®äº†å†…æ ¸å®šæ—¶å™¨ï¼Œåˆ™å°†ç¬¬ä¸€ä¸ªå®šæ—¶å™¨çš„å€¼ -1
    // å¦‚æœå·²ç»åˆ°æ—¶ï¼Œåˆ™è°ƒç”¨ç›¸åº”å¤„ç†ç¨‹åºï¼Œå¹¶ç§»é™¤å®šæ—¶å™¨
    if (next_timer) {
        next_timer->jiffies--;
        while (next_timer && next_timer->jiffies <= 0) {
            void (*fn)(void);
            fn = next_timer->fn;
            next_timer->fn = NULL;
            next_timer = next_timer->next; // åˆ é™¤é˜Ÿå¤´
            (fn)(); // è°ƒç”¨å®šæ—¶å¤„ç†å‡½æ•°
        }
    }
    
    // è½¯ç›˜
    if (current_DOR & 0xf0)
        do_floppy_timer();
    
    // å½“å‰è¿›ç¨‹æ—¶é—´ç‰‡è¿˜æ²¡ç”¨å®Œï¼Œç»§ç»­æ‰§è¡Œ
    if ((--current->counter) > 0)
        return;
    current->counter = 0;
    if (!cpl) // å†…æ ¸æ€ç¨‹åºï¼Œä¸ä¾èµ– counter è¿›è¡Œè°ƒåº¦
        return;
    schedule();
}
```

#### ä¸è¿›ç¨‹ç›¸å…³çš„å‡ ä¸ªç³»ç»Ÿè°ƒç”¨

```c
// è®¾å®šæ–°å®šæ—¶æ—¶é—´ï¼Œå¹¶è¿”å›åŸå®šæ—¶æ—¶é—´çš„å‰©ä½™å€¼
// alarm çš„æ—¶é—´å•ä½æ˜¯ç³»ç»Ÿæ»´ç­”ï¼Œæ‰€ä»¥è®¾è®¡æ»´ç­”å’Œç§’çš„å•ä½è½¬æ¢
int sys_alarm(long seconds)
{
    int old = current->alarm;
    if (old)
        old = (old-jiffies) / HZ; // å‰©ä½™æ—¶é—´
    current->alarm = (seconds > 0) ? (jiffies + HZ * seconds) : 0;
    return (old);
}
```

```c
// å–å½“å‰è¿›ç¨‹å· pid
int sys_getpid(void)
{
    return current->pid;
}
```

```c
// å–çˆ¶è¿›ç¨‹å· ppid
int sys_getppid(void)
{
    return current->p_pptr->pid;
}
```

```c
// å–ç”¨æˆ·å· uid
int sys_getuid(void)
{
    return current->uid;
}
```

```c
// å–æœ‰æ•ˆç”¨æˆ·å· euid
int sys_geteuid(void)
{
    return current->euid;
}
```

```c
// å–ç»„å· gid
int sys_getgit(void)
{
    return current->gid;
}
```

```c
// å–æœ‰æ•ˆçš„ç»„å· egid
int sys_getegit(void)
{
    return current->egid;
}
```

```c
// é™ä½å¯¹ CPU çš„ä½¿ç”¨æƒ
int sys_nice(long increment)
{
    if (current->priority - increment > 0) // é˜²æ­¢ä¼˜å…ˆæƒå¢å¤§
        current->priority -= increment;
    return 0;
}
```

#### å†…æ ¸è°ƒåº¦åˆå§‹åŒ–ç¨‹åº

```c
void sched_init(void)
{
    int i;
    struct desc_struct *p; // æè¿°ç¬¦è¡¨
    
    // å…¼å®¹ POSIX æ ‡å‡†ï¼Œå¹¶æ— å®é™…æ„ä¹‰
    if (sizeof(struct sigaction) != 16)
        panic("Struct sigaction MUST be 16 bytes");
    
    // åœ¨ GDT ä¸­è®¾ç½® Task 0 çš„ TSS å’Œ LDT
    // FIRST_TSS_ENTRY == 4
    // FIRST_LDT_ENTRY == 5
    // gdt æ˜¯ä¸€ä¸ªæè¿°ç¬¦è¡¨æ•°ç»„
    set_tss_desc(gdt+FIRST_TSS_ENTRY, &(init_task.task.tss));
    set_ldt_desc(gdt+FIRST_LDT_ENTRY, &(init_task.task.ldt));
    
    // åˆå§‹åŒ–ä»»åŠ¡æ•°ç»„å’Œæè¿°ç¬¦è¡¨é¡¹
    p = gdt + FIRST_TSS_ENTRY + 2; // æŒ‡å‘ GDT ç¬¬å…­é¡¹
    for (i = 1; i < NR_TASKS; i++) { // è·³è¿‡äº† Task 0
        task[i] = NULL;
        p->a = p->b = 0;
        p++;
        p->a = p->b = 0;
        p++;
    }
    
    // å¤ä½ NT æ ‡å¿—
    __asm__("pushfl; andl $0xffffbfff, (%esp); popfl");
    
    // åŠ è½½ Task 0 çš„ TSS å’Œ LDT
    // åªæ‰‹åŠ¨åŠ è½½è¿™ä¸€æ¬¡ï¼Œä¹‹åæ–°ä»»åŠ¡çš„ LDT ç”± CPU æ ¹æ® TSS ä¸­çš„ LDT é¡¹è‡ªåŠ¨åŠ è½½
    ltr(0);
    lldt(0);
    
    // åˆå§‹åŒ– 8253 å®šæ—¶å™¨
    // é€šé“ 0ï¼Œå·¥ä½œæ–¹å¼ 3
    // è¾“å‡ºå¼•è„šæ¥åœ¨ 8259 ä¸»èŠ¯ç‰‡çš„ IRQ0 ä¸Š
    // 10ms å‘å‡ºä¸€æ¬¡ IRQ0 è¯·æ±‚
    outb_p(0x36, 0x43);
    outb_p(LATCH & 0xff, 0x40);
    outb(LATCH >> 8, 0x40);
    
    // è®¾ç½®æ—¶é’Ÿä¸­æ–­é—¨ï¼Œä¿®æ”¹ä¸­æ–­æ§åˆ¶å™¨å±è”½ç ï¼Œå…è®¸æ—¶é’Ÿä¸­æ–­
    // è®¾ç½®ç³»ç»Ÿè°ƒç”¨ä¸­æ–­é—¨
    set_intr_gate(0x20, &timer_interrupt);
    outb(inb_p(0x21) & ~0x01, 0x21);
    set_system_gate(0x80, &system_call);
}
```

---

## Summary

è¿™ä¸ªç¨‹åºæ„Ÿè§‰ç®—æ˜¯å†…æ ¸é‡Œæœ€å¤æ‚çš„ä»£ç äº†å­

ä¸æ˜¯å› ä¸ºé€»è¾‘å¤æ‚

æ˜¯å› ä¸ºæ¶‰åŠåˆ°è¿›ç¨‹çŠ¶æ€çš„è½¬æ¢ã€è¿›ç¨‹çš„åˆ‡æ¢

å› æ­¤ä»£ç æ‰§è¡Œå°±ä¸æ˜¯è¿ç»­çš„äº†

---

